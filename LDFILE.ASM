
;	LSX-Dodgers FILE

FILEC:
	CALL	FILE
FILEC2:
	LD	A,(FDRV+1)
	CP	020H
	RET	Z
	JR	SETDIR1

FILE:
	XOR	A
	LD	(FDRV),A
	LD	H,A
	LD	L,A
	LD	(FDRV+14),HL
	CALL	SPCUT
	CALL	CCHK3
	JR	Z,DEVI1
	INC	DE
	LD	A,(DE)
	DEC	DE
	CP	':'
	JR	NZ,DEVI1
	LD	A,(DE)		;DRIVE
	CALL	CAP
	SUB	'@'
	INC	DE
	INC	DE
	LD	(FDRV),A
DEVI1:
	LD	A,(DE)
	SUB	05CH		;\
	JR	NZ,NOROOT
	LD	L,A		;A=0でH=0のはずなのでHL=0
	LD	(FDRV+26),HL
	INC	L
	LD	(FDRV+14),HL
	INC	DE
NOROOT:

SETDIR:
	CALL	FILED
	LD	A,(DE)
	CP	05CH		;\
	RET	NZ
	INC	DE
SETDIR1:
	LD	A,010H		;Directory
	LD	(FDRV+13),A
	PUSH	DE
	LD	DE,FDRV
	LD	HL,(STABLE+2*00FH)
	CALL	JP_HL
	POP	DE
	OR	A
	RET	NZ

	LD	A,(FDRV+13)
	BIT	4,A
	RET	Z

	CALL	FILEI
	LD	HL,(FDRV+26)
	INC	HL
	LD	(FDRV+14),HL
	JR	SETDIR

FILED:
	CALL	FILEI
	LD	HL,FNAME

	LD	B,8
FILE2:
	CALL	CCHKF
	RET	Z
	CP	'*'
	JR	Z,FILE9
	CP	'.'
	JR	Z,FILE4
	LD	(HL),A
	INC	HL
	DJNZ	FILE2

FILE3:
	CALL	CCHKF
	RET	Z
	CP	'.'
	JR	NZ,FILE3

FILE4:
	LD	HL,FNAME+8
	LD	B,3

FILE4L:
	CALL	CCHKF
	RET	Z
	CP	'.'
	JR	NZ,FILE12
	LD	(FNAME),A	;Parent directory(..)
	LD	(FNAME+1),A
	LD	A,020H
FILE12:
	CP	'*'
	JR	Z,FILE10
	LD	(HL),A
	INC	HL
	DJNZ	FILE4L
	RET

FILE9:				;名前の*処理、名前の残りを?で埋める
	CALL	FILE10
	JR	FILE3

FILE10:
	LD	A,'?'
	JR	FILL_MEMORY
FILEI:				;名前＋拡張子をスペースで初期化
	LD	A,020H
	LD	BC,11*256	;C=0にしておく
	LD	HL,FNAME
FILL_MEMORY:			;HLからBバイトAで埋める
	LD	(HL),A
	INC	HL
	DJNZ	FILL_MEMORY
	RET

CCHKF:
	LD	A,(DE)
	CALL	CCHK2
	RET	Z
	JP	FKAN

CCHK2:
	INC	C
	DEC	C
	RET	NZ
CCHK3:				;ZF=1 で使えない文字
	CP	'+'
	RET	Z
	CP	','
	RET	Z
	CP	'/'
	RET	Z
	CP	':'
	RET	Z
	CP	';'
	RET	Z
	CP	'='
	RET	Z
	CP	05CH	;\
	RET	Z
	CP	020H
	RET	NC
	CP	A		;Z=1
	RET

SS1:
	INC	DE
SPCUT:				;スペースをカット
	LD	A,(DE)
	CP	020H
	JR	Z,SS1
	RET

SETDRVF:
	LD	DE,FDRV
SETDRV0:
	CALL	SETDRV
	POP	IY
	POP	BC
	POP	DE
	POP	HL
	RET

SETDRV:
	EX	(SP),HL		;HL=RETRN ADDRESS
	PUSH	DE		;PUSH HL/DE/BC/IY
	PUSH	BC
	LD	A,(DE)
	PUSH	DE
	EX	(SP),IY

	CALL	GETDRV
	INC	A
	LD	(IY+0),A	;(FCB)ドライブ番号
	DEC	A
	CALL	_CHGDRV

	JP	(HL)

GETDRV:
	AND	07FH
	SUB	001H
	JR	NC,GETDRV1
	LD	A,(_DVSW)	;Current Drive
GETDRV1:
	LD	(_DRV),A
	RET

SOPENX:
	CALL	CHKDDX
	JR	C,SOPENX1
	POP	BC
	JP	(HL)
SOPENX1:
	LD	DE,SFILE
	LD	A,(DE)
	CP	(IY+0)		;(FCB)ドライブ番号
	JR	NZ,SOPEN
	INC	DE
	PUSH	IY
	POP	HL
	INC	HL
	CALL	CPFILE
	JR	NZ,SOPEN

	LD	HL,(SCDIR)
	LD	(IY+14),L	;(FCB)アクセスするディレクトリのクラスタ番号+1
	LD	(IY+15),H

	LD	HL,(SFNDF)	;Direcroty location and Flags
	LD	(_FILEN),HL

	LD	DE,(SFBPS)
	LD	HL,SFILE
	LD	(HL),0FFH
	INC	HL
	RET
SOPEN:
	LD	HL,FILESE
SOPENC:
	LD	(OPENPAT+1),HL

	CALL	_RDFATX		;Detect Media
	JR	C,RDDERR

	XOR	A
	LD	(_FILEN),A
	CALL	LDDIRX1		;A=0で呼び出す
	JR	Z,SDIRX1

	CALL	READ_DIR	;Sub Directory
	JR	C,SDIRX0
	LD	HL,(_DTBUF)
	LD	A,(HL)
	CP	'.'
	JR	Z,SOPEN1
SDIRX0:
	XOR	A
	LD	(_DIRF),A
	LD	(IY+14),1	;(FCB)レコードサイズ
	LD	(IY+15),A
SDIRX1:
	LD	DE,(_DIRPS)	;Root Directory
SOPEN1:
SDECPAT:LD	C,32		;自己書き換え 1セクタ辺りのディレクトリエントリ数  1024=32 / 512=16
SOPEN1X:
	CALL	READ_DIR	;FILE SEARCH
	JR	C,RDDERR
	LD	HL,(_DTBUF)
SOPEN2:
	PUSH	DE
OPENPAT:CALL	FILESE		;(Self-rewriting)
	POP	DE
	JR	C,SOPENE
	JR	Z,SCF_FF_RET
SOPEN3:
	LD	A,(_DIRF)	;ディレクトリか判別
	OR	A
	JR	NZ,SOPEN5
	INC	DE		;ルートディレクトリ
	PUSH	HL
MD_PAT:	LD	HL,12		;(Self-rewriting)MAXDIR
	SBC	HL,DE		;CF=0 なので SUB HL,DE
	POP	HL
	JR	NZ,SOPEN1
	JR	SOPEN6
SOPEN5:
	CALL	GNCLX		;END DIR
	RET	C
	CALL	ENDCL
SOPEN6:
	JR	C,SOPEN1
SCF_FF_RET:
	SCF			;CF=1
	SBC	A,A		;A=0FFH
	RET

RDDERR:
	CP	A		;READ ERR CF=1 ZF=1
	SCF
	RET

NOPEN:
	LD	HL,FILESE
	LD	(OPENPAT+1),HL
	LD	IY,(_FCB)
	CALL	CHKWILDX
	JR	NC,SCF_FF_RET
	LD	A,(IY+0)	;(FCB)ドライブ番号
	DEC	A
	LD	(_DRV),A
	CALL	_CHGDRV
	RET	C
	LD	HL,(SFNDF)	;Direcroty location and Flags
	LD	(_FILEN),HL

	CALL	LDDIRX
	LD	DE,(_FBPS)
	CALL	READ_DIR
	JR	C,RDDERR
	LD	A,(_FBCNT)
	DEC	A
	JR	Z,SOPEN3
NOPEN2:
	LD	HL,(_FBAD)
	LD	BC,020H
	ADD	HL,BC
	LD	C,A
	JR	SOPEN2

SOPENE2:
	LD	(_FBAD),HL
	LD	A,C
	LD	(_FBCNT),A
	LD	(_FBPS),DE
	LD	(_FCB),IY
SOPENE:
	XOR	A
	RET

COPEN:
	LD	(IY+13),020H	;(FCB)属性(アトリビュート)

	LD	HL,NEXTSE
	CALL	SOPENC
	RET	NC
	RET	Z
	LD	A,(_DIRF)	;ディレクトリか判別
	OR	A
	SCF
	RET	Z		;ルートディレクトリ
	LD	B,1
	CALL	WRDF
	RET	C
	LD	DE,(_CLPS)
	PUSH	DE
	CALL	DCPAT
	CALL	DRDNX
	LD	HL,(_DTBUF)	;ディレクトリエントリを0クリア
	LD	E,L
	LD	D,H
	INC	DE		;DE,DTBUF+1
SECSZM1:LD	BC,003FFH	;自己書き換え セクタサイズ-1(0x3FF:1023 or 0x1FF:511 or 0xFF:255)
	XOR	A		;データバッファをセクタサイズ分ゼロクリア
	LD	(HL),A
	LDIR
	POP	DE		;DE=(_CLPS)
	PUSH	DE
	LD	A,(SPCPAT+1)	;1クラスタの論理セクタ数
	DEC	A
	JR	Z,COPENE
	LD	A,1		;1セクタ辺りのセクタ数が2以上の場合
	LD	(_SECPS+1),A
COPEN1:
	PUSH	DE		;データバッファに入らないセクタもゼロクリア
	PUSH	BC
	LD	HL,(_DTBUF)
	CALL	CLUSTX
	CALL	DWT24
	POP	BC
	POP	DE
	CALL	NEXTX
	JR	NZ,COPEN1
COPENE:
	LD	HL,(_DTBUF)
	POP	DE
	RET

READ_DIR:
	LD	(_CLPS),DE
	PUSH	BC
	PUSH	DE
	CALL	DCPAT
	CALL	DRDX
	POP	DE
	POP	BC
	RET

FILESE:
	LD	A,(HL)
	OR	A
	RET	Z		;END:ZF=1 CF=0
	CP	0E5H
	JR	Z,FILESE1
	PUSH	IY
	POP	DE
	INC	DE
	PUSH	HL
	CALL	CPFILE
	CALL	Z,CPFILE2
	POP	HL
	SCF
	RET	Z		;!!!:(ZF=1) CF=1
FILESE1:
	CALL	FNEXT
	JR	NZ,FILESE
ZF0_CF0_AFF_RET:
	OR	0FFH		;ZF=0 CF=0
	RET

NEXTSE:
	LD	A,(HL)
	OR	A
	SCF
	RET	Z		;!!!:ZF=1 CF=1
	CP	0E5H
	SCF
	RET	Z		;!!!:(ZF=1) CF=1
	CALL	FNEXT
	JR	NZ,NEXTSE
	JR	ZF0_CF0_AFF_RET

FNEXT:
	PUSH	HL
	LD	HL,_FILEN
	INC	(HL)
	POP	HL
	LD	DE,020H
	ADD	HL,DE
	DEC	C
	RET

CHKDDX:
	CALL	CHKWILDX
	RET	C
	PUSH	IY
	POP	DE
	INC	DE
	LD	HL,DDTB
	LD	B,DDS
CPNAME:
	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	CPFILE4
	POP	HL
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	POP	DE
	POP	BC
	JR	NZ,CPNAME1
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	RET
CPNAME1:
	INC	HL
	INC	HL
	DJNZ	CPNAME
	SCF
	RET

CPFILE4:
	PUSH	BC
	LD	BC,00400H
	JR	CPSTR1
CPFILE:
	PUSH	BC
	LD	BC,00B00H
CPSTR1:
	LD	A,(DE)
	CP	'?'		;Wild card
	JR	Z,CPSTR2
	LD	A,(HL)
	CALL	FKANC
	PUSH	HL
	LD	H,A
	LD	A,(DE)
	RLC	C
	CALL	FKANC
	RRC	C
	CP	H		;CP (HL),(DE)
	POP	HL
	JR	NZ,CPSTR3
CPSTR2:
	INC	DE
	INC	HL
	DJNZ	CPSTR1
CPSTR3:
	POP	BC
	RET

CPFILE2:
	LD	A,(IY+13)	;(FCB)属性(アトリビュート)
	OR	0E1H
	CPL
	AND	(HL)
	RET

DCPAT:
	LD	C,0
	LD	HL,(_DTBUF)
	LD	A,(_DIRF)	;ディレクトリか判別
	OR	A
	RET	Z		;ルートディレクトリの場合はCレジスタを0にしておく(CDEがセクタ番号)
	LD	A,(SPCPAT+1)
	LD	C,A
	LD	A,(_SECPS+1)
	CP	C
	JR	NC,DC1
	XOR	A
DC1:
	OR	080H
	LD	(_DIRF),A	;bit0-6:セクタインデックス
CLUSTX:
	PUSH	HL
	EX	DE,HL
	XOR	A
SPCPAT:	LD	C,1		;自己書き換え（1クラスタの論理セクタ数）
L_CLDBL:
	RR	C		;->CF
	JR	C,E_CLDBL
	ADD	HL,HL		;*2
	ADC	A,A
	JR	L_CLDBL
E_CLDBL
	LD	C,A
	LD	A,(_SECPS+1)
	OR	L
	LD	L,A
CLSPAT:	LD	DE,8	;+8 (2D)  !ADDCL (Self-rewriting)
	XOR	A
	ADD	HL,DE	;データ格納領域の先頭論理セクタ番号
	ADC	A,C
	LD	C,A
	EX	DE,HL
	POP	HL
	RET

ENDCL:
	LD	A,D	;END CLUSTER
CLPAT1:	CP	1	;164=356	(Self-rewriting)
	RET	NZ
	LD	A,E
CLPAT2:	CP	064H	;		(Self-rewriting)
	RET

CAP:
	CP	'a'
	RET	C
	CP	'z'+1
	RET	NC
	SUB	020H
	RET
CAP2:
	CALL	CAP
CAP3:
	CALL	CAP4
	CP	021H
	RET	NC
	LD	A,0A0H
	RET
CAP4:
	CP	5
	RET	NZ
	LD	A,0E5H
	RET

CHDIR:
	CALL	GETDPBD
	JR	C,CHDIR2
	LD	(IX+01AH),L		;_SDIR_
	LD	(IX+01BH),H		;_SDIR_+1
	JR	CHDIR2		;POP_IX_RET

LDDIR:
	CALL	GETDPBD
	LD	E,(IX+01AH)		;_SDIR_
	LD	D,(IX+01BH)		;_SDIR_+1
	INC	DE
	LD	(IY+14),E	;(FCB)アクセスするディレクトリのクラスタ番号+1
	LD	(IY+15),D
	DEC	DE
	XOR	A
	LD	(_DIRF),A
CHDIR2:
	POP	IX
	RET

LDDIRX:
	LD	A,(_DIRF)	;(FCB)アクセスするディレクトリのセクタインデックス
	AND	07FH
LDDIRX1:
	LD	(_SECPS+1),A
	LD	E,(IY+14)	;(FCB)アクセスするディレクトリのクラスタ番号+1
	LD	D,(IY+15)
	DEC	DE
	CALL	ENDCL
	CALL	NC,LDDIR
LDDIRS:
	LD	A,D
	OR	E
	LD	(_DIRF),A	;ディレクトリか判別
	RET

KILL:
	CALL	CHKWILDX
	JR	C,KILLW
	CALL	CHKDDX
	CCF
	CALL	NC,SOPENX1
KILLS:
	LD	A,01FH
	CALL	NC,CHKATT
	RET	C
KILLSX:
	LD	(HL),0E5H	;DIR
	CALL	WTDB
	LD	DE,01AH
	ADD	HL,DE
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	JR	KILLS2
KILLS1:
	LD	DE,(_CLPS)	;FAT
KILLS2:
	CALL	ENDCL
	RET	NC		;CF=0
	LD	HL,0-2
	ADD	HL,DE
	RET	NC		;DE= 0 or 1
	PUSH	DE
	CALL	_GNCL
	LD	(_CLPS),DE
	POP	DE
	LD	HL,0
	CALL	NC,_SNCL
	JR	NC,KILLS1
	RET

KILLW:
	CALL	SOPEN
KILLW1:
	JR	C,KILLW2
	CALL	SOPENE2
	CALL	KILLS
	CALL	NOPEN
	JR	KILLW1
KILLW2:
	RET	Z
	CCF
	RET

CHKATT:
	PUSH	HL
	LD	DE,00BH
	ADD	HL,DE
	AND	(HL)
	POP	HL
	RET	Z
	SCF
	RET

NAME:
	CALL	CHKWILDX
	RET	C
	LD	DE,4
	ADD	HL,DE
	LD	(NAMEP+2),HL
	INC	HL
	CALL	CHKWILD
	RET	C

	CALL	SOPENX1
	LD	A,00FH
	CALL	NC,CHKATT
	RET	C

	LD	A,(IY+0)
	PUSH	IY
NAMEP:	LD	IY,0
	LD	(IY+0),A
	CALL	SOPENX1
	EX	(SP),IY
	CCF
	CALL	NC,SOPEN
	EX	DE,HL
	POP	HL
	RET	C

SETNAME:
	LD	BC,11*256
	INC	HL
	LD	A,(HL)
	CP	0E5H
	JR	NZ,SNAME1
	LD	A,5
	JR	SNAME3
SNAME1:
	LD	A,(HL)
	INC	C
	DEC	C
	JR	NZ,SNAME3
	CALL	CAP
	CP	0A0H
	JR	NZ,SNAME3
	LD	A,020H
SNAME3:
	LD	(DE),A
	LD	A,(HL)
	INC	HL
	CALL	FKAN
	DJNZ	SNAME1
WTDB:
	LD	A,0FFH
	LD	(SFILE),A
SWTDBF:
	LD	A,1
	LD	(_WTDBF),A
	XOR	A
	RET

FKANC:
	BIT	0,C
	CALL	Z,CAP2
	JR	FKANX
FKAN:			;漢字チェック
	INC	DE
FKANX:
	BIT	0,C
	RES	0,C
	RET	NZ
	CP	080H
	RET	C
	CP	0A0H
	JR	C,FKAN1
	CP	0E0H
	RET	C
FKAN1:
	INC	C
	AND	A
	RET

CHKWILDX:
	PUSH	IY
	POP	HL
	INC	HL
CHKWILD:
	LD	B,11
	LD	A,'?'
CHKWIL1:
	CP	(HL)
	INC	HL
	SCF
	RET	Z
	DJNZ	CHKWIL1
	XOR	A
	RET

SDIRENT:		;IY=FCB HL=DIR
	PUSH	DE
	PUSH	HL
	PUSH	IY
	POP	DE
	EX	DE,HL
	CALL	SETNAME
;				Attribute
	LD	A,(IY+13)	;(FCB)属性(アトリビュート)
	LD	(DE),A
	INC	DE
;				Reserved
	XOR	A
	LD	B,10
SDE1:
	LD	(DE),A
	INC	DE
	DJNZ	SDE1
					;(FCB)更新時刻
	LD	HL,SDDATA		;(FCB)更新年月日
	LD	B,SDDATAE-SDDATA	;(FCB)ファイルの先頭クラスタ
SDLOOP:					;(FCB)ファイルのサイズ(バイト単位)
	LD	A,(HL)
	INC	HL
	LD	(SDPAT+2),A
SDPAT:	LD	A,(IY+0)	;LD A,(IY+A)
	LD	(DE),A
	INC	DE
	DJNZ	SDLOOP

	XOR	A
	POP	HL
	POP	DE
	RET

WOPEN:
	LD	A,(IY+13)	;(FCB)属性(アトリビュート)
	AND	01FH
	SCF
	RET	NZ
	LD	(IY+28),0FEH	;(FCB)オープンモード
TOPEN2:
	XOR	A
TOPEN:				;Initializes the time stamp
	LD	(IY+23),0FFH	;(FCB)更新時刻
	RET

WRDFX:
	LD	A,(SPCPAT+1)	;1クラスタの論理セクタ
L_WRFX:
	RRA		;->CF
	JR	C,E_WRFX
	SRL	C	;C=C/2
	JR	L_WRFX
E_WRFX:
	LD	B,C
	INC	B
	LD	A,037H		;SCF
	LD	(DRDN1),A

WRDF:				;Bクラスタ分FATを確保する
	LD	DE,2
	XOR	A
	LD	(_SECPS+1),A
WRDF1:
	PUSH	BC
	PUSH	DE
	CALL	_GNCL
	JR	C,WRDF3
	LD	A,D		;空いているかチェック
	OR	E
	JR	NZ,WRDF4
	POP	HL		;HL=空いているクラスタ
	PUSH	HL
	LD	DE,(_CLPS)	;DE=元の(_CLPS)
	LD	(_CLPS),HL
	LD	A,D		;元の(_CLPS)が 0 か?
	OR	E
	JR	NZ,WRDF2
	LD	(IY+26),L	;(FCB)ファイルの先頭クラスタ
	LD	(IY+27),H	;元が空の場合はFCBにクラスタをセットする
	JR	WRDF3
WRDF2:
	CALL	_SNCL
WRDF3:
	POP	DE
	POP	BC
	RET	C
	DJNZ	WRDF5		;ここでループカウンタチェック
	LD	DE,(_CLPS)
	LD	HL,0FFFFH	;FATエントリ終了(EOCマーク)
	JP	_SNCL

WRDF4:				;DEクラスタが空じゃないので次に移動する
	POP	DE
	POP	BC
WRDF5:
	INC	DE
	CALL	ENDCL
	JR	C,WRDF1
	SCF
	RET

RWXR:
	LD	A,(SECSZ+2)	;1024=4 / 512=2 / 256=1
L_RWX:
	RRA		;->CF
	JR	C,E_RWX
	SRL	B	;BC=BC/2
	RR	C	;
	JR	L_RWX
E_RWX:
	LD	E,(IY+26)	;(FCB)ファイルの先頭クラスタ
	LD	D,(IY+27)
	XOR	A
	LD	(_SECPS+1),A
RWX1:
	LD	(_CLPS),DE
	LD	A,D
	OR	E
	JR	Z,SCF_RET	;RET DE==0 => CF=1

	LD	A,B
	OR	C
	RET	Z		;RET BC==0 => CF=0

	CALL	GNCLX
	RET	C
	DEC	BC

	CALL	ENDCL
	JR	C,RWX1
SCF_RET:
	SCF
	RET

DSKF:
MAXCLP:	LD	DE,0
	LD	HL,(_FAKEFREE)
	LD	A,H
	OR	L
	JR	Z,DSKF1
	LD	DE,1
DSKF1:
	PUSH	DE
	CALL	_GNCL
	JR	C,POPSCF
	LD	A,D
	OR	E
	JR	NZ,DSKF2
	INC	HL
DSKF2:
	POP	DE
	DEC	DE
	LD	A,D
	OR	E
	JR	NZ,DSKF1
	RET

POPSCF:
	POP	AF
	SCF
	RET

SETTMS:
	LD	A,(IY+23)	;(FCB)ファイルを最後に変更した時刻
	INC	A
	RET	NZ		;ファイルが更新されていない
SETTMSX:			;FCBに日付時刻をセットする
	CALL	_SYS2C		;(BDOS)時刻の獲得
				;H←時  L←分  D←秒
	SLA	L		;L=L/2
	SLA	L		;L=L/2
	ADD	HL,HL		;*2
	ADD	HL,HL		;*4
	ADD	HL,HL		;*8
	LD	A,D
	RRCA			;bit.0->7->->->0->C
	AND	01FH
	OR	L
	LD	(IY+22),A	;(FCB)ファイルを最後に変更した時刻
	LD	(IY+23),H

	CALL	_SYS2A		;(BDOS)日付の獲得
				;HL←年  D←月  E←日
	LD	BC,0-1980
	ADD	HL,BC
	LD	H,L

	LD	A,D
	ADD	A,A		;*2
	ADD	A,A		;*4
	ADD	A,A		;*8
	ADD	A,A		;*16
	LD	L,A
	ADD	HL,HL		;*32
	LD	A,L
	OR	E
	LD	(IY+20),A	;(FCB)ファイルを最後に変更した日付
	LD	(IY+21),H
	RET

PUSHRR:
	CALL	SUBRR
POPRR1:
	LDIR
	RET

SUBRR:
	PUSH	IY
	POP	HL
	LD	DE,33
	ADD	HL,DE
	LD	DE,HLBUF
	LD	BC,3
	RET

SETSEQ:
	PUSH	AF		;AHL=Random record
	LD	A,(IY+33)	;(FCB)ランダムレコード
	LD	L,(IY+34)
	LD	H,(IY+35)

	CALL	SSQ1

	ADD	HL,HL
	SRL	L		;L=L/2
	LD	(IY+32),L	;(FCB)カレントレコード
	LD	(IY+12),H	;(FCB)カレントブロック
	POP	AF

POPRR:
	CALL	SUBRR
	EX	DE,HL
	JR	POPRR1

GETSIZE:
	LD	A,(IY+16)	;(FCB)ファイルのサイズ(バイト単位)
	LD	L,(IY+17)
	LD	H,(IY+18)
SSQ1:				;バイト単位からCP/Mのレコード単位を求める（1レコード=128バイト）
	ADD	A,A		;in HLA => out HL
	ADC	HL,HL
	OR	A
	RET	Z
	INC	HL
	RET

GETSEQ:
	LD	L,(IY+32)	;(FCB)カレントレコード
	LD	H,(IY+12)	;(FCB)カレントブロック

	SLA	L	;L=L*2

	SRL	H	;HL=HL/2
	RR	L	;
	RET

RB_WRITE:
	PUSH	BC
	LD	BC,(STABLE+2*026H)	;(BDOS)ランダムブロック書き込み
	JR	RBRW
RB_READ:
	PUSH	BC
	LD	BC,(STABLE+2*027H)	;(BDOS)ランダムブロック読み込み
RBRW:
	XOR	A	;HLA = HL*128
	SRL	H	;HL=HL/2
	RR	L	;
	RRA			;HLA
	LD	(IY+33),A	;(FCB)ランダムレコード
	LD	(IY+34),L
	LD	(IY+35),H
	LD	HL,128

	PUSH	IY
	POP	DE
	PUSH	DE
	CALL	JP_BC
	POP	IY
	POP	BC
	RET
JP_BC:
	PUSH	BC
	RET

_SYS03	EQU	SCF_FF_RET	;(BDOS)外部入力
_SYS2B	EQU	SCF_FF_RET	;(BDOS)日付の設定
_SYS2D	EQU	SCF_FF_RET	;(BDOS)時刻の設定
